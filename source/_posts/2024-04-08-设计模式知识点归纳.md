---
title: 设计模式知识点归纳
date: 2024-04-08 18:06:45
categories:
- 设计模式
tags:
- 设计模式
---

<!-- more -->

## 设计模式

- 创建型模式
  - 简单工厂模式
    - 通过一个工厂类来创建不同的类的实例
  - 工厂方法模式
    - 定义一个用于创建对象的接口，让子类决定实例化哪一个类
  - 抽象工厂模式
    - 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类
  - 建造者模式
    - 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
    - Director 类与抽象工厂的工厂类类似，负责返回一个产品族的所有产品
  - 单例模式
    - 保证一个类仅有一个实例，并提供一个访问它的全局访问点
  - 原型模式
    - 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
- 结构型模式
  - 适配器模式
    - 将一个类的接口转换成客户希望的另一个接口，从而使得原本因接口不匹配而无法在一起工作的类可以一起工作
  - 代理模式
    - 为其他对象提供一种代理以控制对这个对象的访问
    - 和适配器模式最为相似
  - 桥接模式
    - 将抽象部分与它的实现部分分离，使它们都可以独立的变化
  - 过滤器模式
    - 使用不同的标准来过滤一组对象
  - 组合模式
    - 将对象组合成树形结构以表示部分-整体的层次结构
    - 分为透明式和安全式
    - 包含抽象构件 Component、叶子构件 Leaf、容器构件 Composite
  - 装饰模式
    - 动态的给一个对象添加一些额外的职责
    - 包括抽象组件角色 Component、抽象组件实现 ConcreteComponent、装饰器 Decorator、装饰器实现 ConcreteDecorator
  - 外观模式
    - 为子系统中的一组接口提供一个一致的接口，使得子系统更容易使用
  - 享元模式
    - 运用共享技术有效的支持大量细粒度的对象
- 行为型模式
  - 责任链模式
    - 为请求创建一个接收此次请求对象的链
    - 设置一个默认处理器来处理未被处理的请求
  - 命令模式
    - 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化
  - 解释器模式
    - 给定一个语言，定义它的文法的一种表示，并定义一个解释器
  - 迭代器模式
    - 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示
  - 中介者模式
    - 用一个中介对象来封装一系列的对象交互，处理多个类之间的交互
    - 同事类依赖于中介者
  - 备忘录模式
    - 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态
    - 符合迪米特法则
  - 观察者模式
    - 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
    - 避免发送者和接受者的耦合
    - 包括抽象主题、具体主题、抽象观察者、具体观察者
  - 状态模式
    - 允许一个对象在其内部状态改变时改变它的行为
  - 空对象模式
    - 用一个对象代表空值
  - 策略模式
    - 定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换
    - 涉及多选一、多重条件选择或所有的策略类
  - 模板模式
    - 定义一个操作中的算法的框架，而将一些步骤延迟到子类中
  - 访问者模式
    - 添加新的操作到已经存在的对象结构中去

## 原则

- 单一职责原则
  - 一个类只负责一个功能
- 开闭原则
  - 对扩展开放，对修改关闭
- 里氏替换原则
  - 子类可以替换父类
- 依赖倒置原则
  - 高层模块不应该依赖底层模块，两者都应该依赖抽象
- 接口隔离原则
  - 使用多个专门的接口，而不使用单一的总接口
- 迪米特法则
  - 一个对象应该对其他对象保持最少的了解
- 合成复用原则
  - 尽量使用合成/聚合，而不是继承